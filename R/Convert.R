findvcfinfovalues <- function(vcfinfo) {
  info <- vcfinfo$additionalinfo$info
  imputed <- as.integer(rep(NA,length(info)))
  aaf <- as.numeric(rep(NA,length(info)))
  maf <- as.numeric(rep(NA,length(info)))
  r2 <- as.numeric(rep(NA,length(info)))
  er2 <- as.numeric(rep(NA,length(info)))
  for (i in 1:length(info)) {
    infovalues <- unlist(strsplit(info[i], ";"))
    if (length(infovalues) > 0) {
      for (j in 1:length(infovalues)) {
        if (infovalues[j] == "IMPUTED")
          imputed[i] <- 1
        if (infovalues[j] == "TYPED")
          imputed[i] <- 0
        infovalues2 <- unlist(strsplit(infovalues[j], "="))
        if (length(infovalues2) == 2) {
          if (infovalues2[1] == "AF") {
            aaf[i] <- as.numeric(infovalues2[2])
          } else if (infovalues2[1] == "MAF") {
            maf[i] <- as.numeric(infovalues2[2])
          } else if (infovalues2[1] == "R2") {
            r2[i] <- as.numeric(infovalues2[2])
          } else if (infovalues2[1] == "ER2") {
            er2[i] <- as.numeric(infovalues2[2])
          }
        }
      }
    }
  }
  df <- data.frame(imputed, aaf, maf, rsq = r2, ersq = er2)
  return(df)
}

readvcfinfofile <- function(vcfinfo, vcfinfofile) {
  vcfinfodf <- read.table(vcfinfofile, header = TRUE, na.strings = "-")
  if (nrow(vcfinfodf) != nrow(vcfinfo$snps)) {
    print("Number of SNPs in VCF file does not match INFO file")
    return (data.frame(0))
  }
  if (all(vcfinfo$snps$SNPID != vcfinfodf$SNP) == FALSE) {
    print("SNPs in VCF and INFO files don't line up")
    return (data.frame(0))
  }
  colsneeded <- match(c("ALT_Frq", "MAF", "Rsq", "Genotyped", "EmpRsq"),
                     colnames(vcfinfodf))
  if (any(is.na(colsneeded == TRUE)) == TRUE) {
    print("Not all imputation information columns found")
    return(data.frame(0))
  }
  imputed <- integer(nrow(vcfinfodf))
  imputed[vcfinfodf$Genotyped == "Imputed"] <- 1
  df <- data.frame(imputed = imputed,
                   aaf = vcfinfodf$ALT_Frq,
                   maf = vcfinfodf$MAF,
                   rsq = vcfinfodf$Rsq,
                   ersq = as.numeric(vcfinfodf$EmpRsq))
  return(df)
}
  
###########################################################
#                  VCF to Binary Dosage                   #
###########################################################

#' Convert a VCF file to a binary dosage file
#'
#' Routine to read information from a VCF file and create
#' a binary dosage file. The function is designed to use
#' files return from the Michigan Imputation Server but will
#' run on other VCF files if they contain dosage and genetic
#' probabilities. Note: This routine can take a long time to
#' run if the VCF file is large.
#'
#' @param vcffiles A vector of file names.
#' The first is the name of the vcf file. The
#' second is name of the file that contains information
#' about the imputation of the SNPs. This file is produced
#' by minimac 3 and 4.
#' @param gz Indicator if VCF file is compressed using gzip.
#' Default value is FALSE.
#' @param bdfiles Vector of names of the output files.
#' The binary dosage file name is first. The family and
#' map files follow. For format 4, no family and map file
#' names are needed.
#' @param bdinfofile Name of file to contains binary dosage
#' information file. This is used to speed up reading of the
#' binary dosage file. If blank the file will not be saved. It
#' can be generated by running the getbdinfo() routine.
#' @param format The format of the output binary dosage file.
#' Allowed values are 1, 2, 3, and 4. The default value is 4.
#' Using the default value is recommended.
#' @param subformat The subformat of the format of the output
#' binary dosage file. A value of 1 or 3 indicates that only the
#' dosage value is saved. A value of 2 or 4 indicates
#' the dosage and genetic probabilities will be output. Values
#' of 3 or 4 are only allowed with formats 3 and 4. If a value
#' of zero if provided, and genetic probabilities are in the vcf
#' file, subformat 2 will be used for formats 1 and 2, and
#' subformat 4 will be used for formats 3 and 4. If the vcf file
#' does not contain genetic probabilities, subformat 1 will be
#' used for formats 1 and 2, and subformat 3 will be used for
#' formats 3 and 4. The default value is 0.
#' @param snpidformat The format that the SNP ID will be saved as.
#' -1 SNP ID not written
#' 0 - same as in the VCF file
#' 1 - chromosome:location
#' 2 - chromosome:location:reference_allele:alternate_allele
#' If snpidformat is 1 and the VCF file uses format 2, an error is
#' generated. Default value is 0.
#' @param bdoptions Character array containing any of the following
#' value, "aaf", "maf", "rsq". The presence of any of these
#' values indicates that the specified values should be
#' calculates and stored in the binary dosage file. These values only
#' apply to format 4.
#'
#' @return
#' None
#' @export
#'
#' @examples
#' # Find the vcf file names
#' vcf1afile <- system.file("extdata", "set1a.vcf", package = "BinaryDosage")
#' vcf1ainfo <- system.file("extdata", "set1a.info", package = "BinaryDosage")
#' bdfiles <- tempfile()
#' # Convert the file
#' vcftobd2(vcffiles = c(vcf1afile, vcf1ainfo), bdfiles = bdfiles)
#' # Verify the file was written correctly
#' bdinfo <- getbdinfo(bdfiles)
vcftobd2 <- function(vcffiles,
                     gz = FALSE,
                     bdfiles,
                     bdinfofile,
                     format = 4L,
                     subformat = 0L,
                     snpidformat = 0,
                     bdoptions = character(0)) {
  if (missing(vcffiles) == TRUE)
    stop("No VCF file specified")
  
  if (missing(bdfiles) == TRUE)
    stop("No output files specified")
  
  if (missing(bdinfofile) == TRUE)
    bdinfofile <- ""
  
  validation <- BinaryDosage:::validatebdinput(bdfiles = bdfiles,
                                               format = format,
                                               subformat = subformat,
                                               snpidformat = snpidformat,
                                               bdoptions = bdoptions)
  format <- validation$format
  subformat <- validation$subformat
  
  if (snpidformat == -1)
    readsnpformat = 0
  else
    readsnpformat = snpidformat
  vcfinfo <- BinaryDosage::getvcfinfo(vcffiles = vcffiles,
                                      gz = gz,
                                      index = FALSE,
                                      snpidformat = readsnpformat)
  if (snpidformat == -1)
    vcfinfo$snpidformat = 1
  else
    vcfinfo$snpidformat = 0
  
  if (subformat == 0) {
    if (anyNA(vcfinfo$additionalinfo$datacolumns$genotypeprob) == TRUE)
      subformat <- 1
    else
      subformat <- 2
  }
  BinaryDosage:::WriteBinaryDosageHeader(format = format,
                                         subformat = subformat,
                                         filename = bdfiles,
                                         genefileinfo = vcfinfo,
                                         bdoptions = bdoptions)
  headerinfo <- BinaryDosage:::ReadBinaryDosageHeader(filename = bdfiles)
  bdwriteinfo <- BinaryDosage:::AllocateBinaryDosageWriteMemory(headerinfo = headerinfo)
  BinaryDosage::vcfapply(vcfinfo = vcfinfo,
                         func = BinaryDosage:::WriteBinaryDosageData,
                         writeinfo = bdwriteinfo)
  BinaryDosage:::WriteBinaryDosageIndices(writeinfo = bdwriteinfo)
  bdinfo <- BinaryDosage::getbdinfo(bdfiles = bdfiles)
  if (is.na(match("aaf", bdoptions)) == FALSE)
    updateaaf(bdinfo)
  if (is.na(match("maf", bdoptions)) == FALSE)
    updatemaf(bdinfo)
  if (is.na(match("rsq", bdoptions)) == FALSE)
    updatersq(bdinfo)
  
  if (bdinfofile != '') {
    if (length(vcffiles) == 1) {
      bdinfo$additionalinfo$vcfinfo <- findvcfinfovalues(vcfinfo)
    } else {
      bdinfo$additionalinfo$vcfinfo <- readvcfinfofile(vcfinfo,vcffiles[2])
    }
    saveRDS(bdinfo, bdinfofile)    
  }
}
